--- a/coreutils/date.c
+++ b/coreutils/date.c
@@ -119,14 +119,15 @@
 //usage:	) IF_LONG_OPTS(
 //usage:     "\n	-r,--reference FILE	Display last modification time of FILE"
 //usage:     "\n	-d,--date TIME	Display TIME, not 'now'"
 //usage:	)
 //usage:	IF_FEATURE_DATE_ISOFMT(
 //usage:     "\n	-D FMT		Use FMT for -d TIME conversion"
 //usage:	)
+//usage:     "\n	-k		Set Kernel timezone from localtime and exit"
 //usage:     "\n"
 //usage:     "\nRecognized TIME formats:"
 //usage:     "\n	hh:mm[:ss]"
 //usage:     "\n	[YYYY.]MM.DD-hh:mm[:ss]"
 //usage:     "\n	YYYY-MM-DD hh:mm[:ss]"
 //usage:     "\n	[[[[[YY]YY]MM]DD]hh]mm[.ss]"
 //usage:	IF_FEATURE_DATE_COMPAT(
@@ -134,26 +135,26 @@
 //usage:	)
 //usage:
 //usage:#define date_example_usage
 //usage:       "$ date\n"
 //usage:       "Wed Apr 12 18:52:41 MDT 2000\n"
 
 #include "libbb.h"
-#if ENABLE_FEATURE_DATE_NANO
-# include <sys/syscall.h>
-#endif
+#include <sys/time.h>
+#include <sys/syscall.h>
 
 enum {
 	OPT_RFC2822   = (1 << 0), /* R */
 	OPT_SET       = (1 << 1), /* s */
 	OPT_UTC       = (1 << 2), /* u */
 	OPT_DATE      = (1 << 3), /* d */
 	OPT_REFERENCE = (1 << 4), /* r */
-	OPT_TIMESPEC  = (1 << 5) * ENABLE_FEATURE_DATE_ISOFMT, /* I */
-	OPT_HINT      = (1 << 6) * ENABLE_FEATURE_DATE_ISOFMT, /* D */
+	OPT_KERNELTZ  = (1 << 5), /* k */
+	OPT_TIMESPEC  = (1 << 6) * ENABLE_FEATURE_DATE_ISOFMT, /* I */
+	OPT_HINT      = (1 << 7) * ENABLE_FEATURE_DATE_ISOFMT, /* D */
 };
 
 static void maybe_set_utc(int opt)
 {
 	if (opt & OPT_UTC)
 		putenv((char*)"TZ=UTC0");
 }
@@ -163,35 +164,38 @@ static const char date_longopts[] ALIGN1
 		"rfc-822\0"   No_argument       "R"
 		"rfc-2822\0"  No_argument       "R"
 		"set\0"       Required_argument "s"
 		"utc\0"       No_argument       "u"
 	/*	"universal\0" No_argument       "u" */
 		"date\0"      Required_argument "d"
 		"reference\0" Required_argument "r"
+		"set-kernel-tz\0" No_argument   "k"
 		;
 #endif
 
 int date_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int date_main(int argc UNUSED_PARAM, char **argv)
 {
+	time_t tt;
+	struct timezone tz;
 	struct timespec ts;
 	struct tm tm_time;
 	char buf_fmt_dt2str[64];
 	unsigned opt;
 	int ifmt = -1;
 	char *date_str;
 	char *fmt_dt2str;
 	char *fmt_str2dt;
 	char *filename;
 	char *isofmt_arg = NULL;
 
 	opt_complementary = "d--s:s--d"
 		IF_FEATURE_DATE_ISOFMT(":R--I:I--R");
 	IF_LONG_OPTS(applet_long_options = date_longopts;)
-	opt = getopt32(argv, "Rs:ud:r:"
+	opt = getopt32(argv, "Rs:ud:r:k"
 			IF_FEATURE_DATE_ISOFMT("I::D:"),
 			&date_str, &date_str, &filename
 			IF_FEATURE_DATE_ISOFMT(, &isofmt_arg, &fmt_str2dt));
 	argv += optind;
 	maybe_set_utc(opt);
 
 	if (ENABLE_FEATURE_DATE_ISOFMT && (opt & OPT_TIMESPEC)) {
@@ -240,14 +244,39 @@ int date_main(int argc UNUSED_PARAM, cha
 #endif
 			argv++;
 		}
 	}
 	if (*argv)
 		bb_show_usage();
 
+	/* Setting of kernel timezone was requested */
+	if (opt & OPT_KERNELTZ) {
+		tt = time(NULL);
+		localtime_r(&tt, &tm_time);
+
+		/* workaround warp_clock() on first invocation */
+		memset(&tz, 0, sizeof(tz));
+		syscall(SYS_settimeofday, NULL, &tz);
+
+		memset(&tz, 0, sizeof(tz));
+#ifdef __USE_MISC
+		tz.tz_minuteswest = -(tm_time.tm_gmtoff / 60);
+#else
+		tz.tz_minuteswest = -(tm_time.__tm_gmtoff / 60);
+#endif
+
+		if (syscall(SYS_settimeofday, NULL, &tz))
+		{
+			bb_perror_msg("can't set kernel time zone");
+			return EXIT_FAILURE;
+		}
+
+		return EXIT_SUCCESS;
+	}
+
 	/* Now we have parsed all the information except the date format
 	 * which depends on whether the clock is being set or read */
 
 	if (opt & OPT_REFERENCE) {
 		struct stat statbuf;
 		xstat(filename, &statbuf);
 		ts.tv_sec = statbuf.st_mtime;
