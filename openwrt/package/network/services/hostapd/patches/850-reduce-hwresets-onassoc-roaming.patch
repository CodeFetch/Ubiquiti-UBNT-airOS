--- a/src/drivers/driver_wext.c
+++ b/src/drivers/driver_wext.c
@@ -31,14 +31,15 @@
 #include "driver.h"
 #include "driver_wext.h"
 
 static int wpa_driver_wext_flush_pmkid(void *priv);
 static int wpa_driver_wext_get_range(void *priv);
 static int wpa_driver_wext_finish_drv_init(struct wpa_driver_wext_data *drv);
 static void wpa_driver_wext_disconnect(struct wpa_driver_wext_data *drv);
+static int wpa_driver_wext_deauthenticate(void *priv, const u8 *addr, int reason_code);
 static int wpa_driver_wext_set_auth_alg(void *priv, int auth_alg);
 static int wpa_driver_wext_set_gen_ie(void *priv, const u8 *ie, size_t ie_len);
 
 int wpa_driver_wext_set_auth_param(struct wpa_driver_wext_data *drv,
 				   int idx, u32 value)
 {
 	struct iwreq iwr;
@@ -195,14 +196,64 @@ int wpa_driver_wext_set_ssid(void *priv,
 		perror("ioctl[SIOCSIWESSID]");
 		ret = -1;
 	}
 
 	return ret;
 }
 
+static int wext_80211_priv(struct wpa_driver_wext_data *drv, int op,
+		void *data, size_t len)
+{
+	struct iwreq iwr;
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+
+	if (len < IFNAMSIZ)
+	{
+		memcpy(iwr.u.name, data, len);
+	}
+	else
+	{
+		iwr.u.data.pointer = data;
+		iwr.u.data.length = len;
+	}
+	if (ioctl(drv->ioctl_sock, op, &iwr) < 0)
+	{
+		return -1;
+	}
+	return 0;
+}
+
+static int wext_80211_set_param(struct wpa_driver_wext_data *drv, int op, int arg)
+{
+	int data[2];
+
+	data[0] = op;
+	data[1] = arg;
+
+#define	IEEE80211_IOCTL_SETPARAM	(SIOCIWFIRSTPRIV+0)
+	if (wext_80211_priv(drv, IEEE80211_IOCTL_SETPARAM, data, sizeof(data)) < 0)
+	{
+		perror("ioctl[IEEE80211_IOCTL_SETPARAM]");
+		fprintf(stderr, "WEXT set80211param op %d arg %d - ", op, arg);
+		return -1;
+	}
+	return 0;
+}
+
+#define IEEE80211_PARAM_ROAMING		12
+static inline int wext_80211_set_roaming_manual(struct wpa_driver_wext_data *drv)
+{
+	return wext_80211_set_param(drv, IEEE80211_PARAM_ROAMING, 2);
+}
+
+static inline int wext_80211_set_roaming_auto(struct wpa_driver_wext_data *drv)
+{
+	return wext_80211_set_param(drv, IEEE80211_PARAM_ROAMING, 1);
+}
 
 /**
  * wpa_driver_wext_set_freq - Set frequency/channel, SIOCSIWFREQ
  * @priv: Pointer to private wext data from wpa_driver_wext_init()
  * @freq: Frequency in MHz
  * Returns: 0 on success, -1 on failure
  */
@@ -872,14 +923,16 @@ static void wpa_driver_wext_send_rfkill(
 }
 
 
 static int wpa_driver_wext_finish_drv_init(struct wpa_driver_wext_data *drv)
 {
 	int send_rfkill_event = 0;
 
+	wext_80211_set_roaming_manual(drv);
+
 	if (!linux_iface_up(drv->ioctl_sock, drv->ifname)) {
 #ifdef CONFIG_IFACE_DOWN_CONTROL
 		if (linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 1) < 0) {
 			if (rfkill_is_blocked(drv->rfkill)) {
 				wpa_printf(MSG_DEBUG, "WEXT: Could not yet enable "
 						"interface '%s' due to rfkill",
 						drv->ifname);
@@ -908,15 +961,21 @@ static int wpa_driver_wext_finish_drv_in
 	wpa_driver_wext_get_range(drv);
 
 	/*
 	 * Unlock the driver's BSSID and force to a random SSID to clear any
 	 * previous association the driver might have when the supplicant
 	 * starts up.
 	 */
-	wpa_driver_wext_disconnect(drv);
+	/* UBNT: Use wext_deauthenticate instead, because it also does mlme DEAUTH, which does disconnect
+	 * in better way, without any fake SSID's with manual roaming combo and etc.
+	 */
+	{
+		u8 any_mac[ETH_ALEN] = { 0, };
+		wpa_driver_wext_deauthenticate(drv, any_mac, WLAN_REASON_DEAUTH_LEAVING);
+	}
 
 	drv->ifindex = if_nametoindex(drv->ifname);
 
 	if (os_strncmp(drv->ifname, "wlan", 4) == 0) {
 		/*
 		 * Host AP driver may use both wlan# and wifi# interface in
 		 * wireless events. Since some of the versions included WE-18
@@ -956,14 +1015,16 @@ void wpa_driver_wext_deinit(void *priv)
 
 	wpa_driver_wext_set_auth_param(drv, IW_AUTH_WPA_ENABLED, 0);
 	/* clean previuosly set optie */
 	wpa_driver_wext_set_gen_ie(drv, NULL, 0);
 
 	eloop_cancel_timeout(wpa_driver_wext_scan_timeout, drv, drv->ctx);
 
+	wext_80211_set_roaming_auto(drv);
+
 	/*
 	 * Clear possibly configured driver parameters in order to make it
 	 * easier to use the driver after wpa_supplicant has been terminated.
 	 */
 	wpa_driver_wext_disconnect(drv);
 
 	netlink_send_oper_ifla(drv->netlink, drv->ifindex, 0, IF_OPER_UP);
@@ -1932,14 +1993,25 @@ static int wpa_driver_wext_deauthenticat
 	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
 	ret = wpa_driver_wext_mlme(drv, addr, IW_MLME_DEAUTH, reason_code);
 	wpa_driver_wext_disconnect(drv);
 	return ret;
 }
 
 
+static inline int
+wext_80211_set_mlme_assoc(void *priv, const u8 *addr)
+{
+	struct wpa_driver_wext_data *drv = priv;
+	int ret;
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+	ret = wpa_driver_wext_mlme(drv, addr, IW_MLME_ASSOC, 0);
+	return ret;
+}
+
+
 static int wpa_driver_wext_set_gen_ie(void *priv, const u8 *ie,
 				      size_t ie_len)
 {
 	struct wpa_driver_wext_data *drv = priv;
 	struct iwreq iwr;
 	int ret = 0;
 
@@ -2144,14 +2216,17 @@ int wpa_driver_wext_associate(void *priv
 		ret = -1;
 	if (params->bssid &&
 	    wpa_driver_wext_set_bssid(drv, params->bssid) < 0)
 		ret = -1;
 	if (drv->cfg80211 &&
 	    wpa_driver_wext_set_ssid(drv, params->ssid, params->ssid_len) < 0)
 		ret = -1;
+	if (params->bssid &&
+		wext_80211_set_mlme_assoc(drv, params->bssid) < 0)
+		ret = -1;
 
 	return ret;
 }
 
 
 static int wpa_driver_wext_set_auth_alg(void *priv, int auth_alg)
 {
