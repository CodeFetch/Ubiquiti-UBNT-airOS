--- a/wpa_supplicant/wpa_supplicant.c
+++ b/wpa_supplicant/wpa_supplicant.c
@@ -47,14 +47,17 @@
 #include "bgscan.h"
 #include "autoscan.h"
 #include "bss.h"
 #include "scan.h"
 #include "offchannel.h"
 #include "hs20_supplicant.h"
 #include "wnm_sta.h"
+#include <sys/types.h>
+#include <dirent.h>
+#include <glob.h>
 
 const char *wpa_supplicant_version =
 "wpa_supplicant v" VERSION_STR "\n"
 "Copyright (c) 2003-2014, Jouni Malinen <j@w1.fi> and contributors";
 
 const char *wpa_supplicant_license =
 "This software may be distributed under the terms of the BSD license.\n"
@@ -630,14 +633,93 @@ void wpa_supplicant_reinit_autoscan(stru
 	if (wpa_s->wpa_state == WPA_DISCONNECTED ||
 	    wpa_s->wpa_state == WPA_SCANNING) {
 		autoscan_deinit(wpa_s);
 		wpa_supplicant_start_autoscan(wpa_s);
 	}
 }
 
+static void send_signal(const char* pidfile, int sig) {
+    FILE* f = fopen(pidfile, "r");
+    if (f) {
+        pid_t pid = 0;
+        fscanf(f, "%u", &pid);
+        fclose(f);
+        if (pid)
+            kill(pid, sig);
+    }
+}
+
+static int linked_over_bridge(char *wifc, char *difc) {
+    glob_t globbuf;
+    FILE* f;
+    char path_brpt[256] = { 0 };
+    char path_brif[256] = { 0 };
+    int i, rc = 0;
+
+    snprintf(path_brpt, sizeof(path_brpt), "/sys/class/net/%s/brport/bridge/brif/*", difc);	//bridge port
+    snprintf(path_brif, sizeof(path_brif), "/sys/class/net/%s/brif/*", difc);				//bridge interface
+
+    if (glob(path_brpt, 0, NULL, &globbuf)) {
+        globfree(&globbuf);
+        if (glob(path_brif, 0, NULL, &globbuf)) {
+            globfree(&globbuf);
+            return rc;
+        }
+    }
+
+    for (i = 0; i < globbuf.gl_pathc && !rc; i++) {
+        if (f = fopen(globbuf.gl_pathv[i], "r")) {
+            if (strstr(globbuf.gl_pathv[i], wifc)) {
+                rc = 1;
+            }
+            fclose(f);
+        }
+    }
+
+    globfree(&globbuf);
+    return rc;
+}
+
+static void wakeup_agents(struct wpa_supplicant *wpa_s) {
+    // speed up DHCPC/PPP(oE) address receival and NTP time update
+#if 1
+    if (!wpa_s->reassociate) {
+        DIR* dir = opendir("/var/run");
+        if (dir) {
+            struct dirent* entry = 0;
+            while ((entry = readdir(dir)) != NULL) {
+                char fullpath[NAME_MAX];
+                int matches = 0;
+                char dif_name[64] = { 0 };
+                if (strncmp("udhcpc.", entry->d_name, 7) == 0) {
+                    if (sscanf(entry->d_name, "udhcpc.%[^p]", dif_name) == 1) {
+                        dif_name[strlen(dif_name) - 1] = '\x0';
+                        if (strstr(dif_name, wpa_s->ifname) || (linked_over_bridge(wpa_s->ifname, dif_name)))
+                            matches = 1;
+                    }
+                } else if (strncmp("ppp", entry->d_name, 3) == 0) {
+                    /* check if it's really pid file, not tdb */
+                    int len = strlen(entry->d_name);
+                    if (len > 5 && strncmp("pid", entry->d_name + len - 3, 3) == 0) {
+                        matches = 1;
+                    }
+                } else if (strncmp("ntpclient", entry->d_name, 9) == 0) {
+                    matches = 1;
+                }
+                if (matches) {
+                    snprintf(fullpath, sizeof(fullpath) - 1, "%s/%s",
+                             "/var/run", entry->d_name);
+                    send_signal(fullpath, 9);
+                }
+            }
+            closedir(dir);
+        }
+    }
+#endif
+}
 
 /**
  * wpa_supplicant_set_state - Set current connection state
  * @wpa_s: Pointer to wpa_supplicant data
  * @state: The new connection state
  *
  * This function is called whenever the connection state changes, e.g.,
@@ -681,15 +763,16 @@ void wpa_supplicant_set_state(struct wpa
 #endif /* IEEE8021X_EAPOL */
 		wpa_s->after_wps = 0;
 		wpa_s->known_wps_freq = 0;
 #ifdef CONFIG_P2P
 		wpas_p2p_completed(wpa_s);
 #endif /* CONFIG_P2P */
 
-		sme_sched_obss_scan(wpa_s, 1);
+                sme_sched_obss_scan(wpa_s, 1);
+                wakeup_agents(wpa_s);
 	} else if (state == WPA_DISCONNECTED || state == WPA_ASSOCIATING ||
 		   state == WPA_ASSOCIATED) {
 		wpa_s->new_connection = 1;
 		wpa_drv_set_operstate(wpa_s, 0);
 #ifndef IEEE8021X_EAPOL
 		wpa_drv_set_supp_port(wpa_s, 0);
 #endif /* IEEE8021X_EAPOL */
